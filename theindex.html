<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Index</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.0.2">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.0.2"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Index</h1>
      Modules: <a href="numericalnim.html">numericalnim</a>, <a href="numericalnim/common/commonTypes.html">numericalnim/common/commonTypes</a>, <a href="numericalnim/differentiate.html">numericalnim/differentiate</a>, <a href="numericalnim/integrate.html">numericalnim/integrate</a>, <a href="numericalnim/interpolate.html">numericalnim/interpolate</a>, <a href="numericalnim/ode.html">numericalnim/ode</a>, <a href="numericalnim/optimize.html">numericalnim/optimize</a>, <a href="numericalnim/private/arraymancerOverloads.html">numericalnim/private/arraymancerOverloads</a>, <a href="numericalnim/rbf.html">numericalnim/rbf</a>, <a href="numericalnim/utils.html">numericalnim/utils</a>.<br/><p /><h2>API symbols</h2>
<dl><dt><a name="%60%24%60" href="#%60%24%60"><span>`$`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `$`(v: Vector): string" href="numericalnim/utils.html#%24%2CVector">utils: proc `$`(v: Vector): string</a></li>
          </ul></dd>
<dt><a name="%60%2A.%3D%60" href="#%60%2A.%3D%60"><span>`*.=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `*.=`[T](v1: var Vector[T]; v2: Vector[T])" href="numericalnim/utils.html#%2A.%3D%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `*.=`[T](v1: var Vector[T]; v2: Vector[T])</a></li>
          </ul></dd>
<dt><a name="%60%2A.%60" href="#%60%2A.%60"><span>`*.`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `*.`[T](v1, v2: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2A.%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `*.`[T](v1, v2: Vector[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60%2A%3D%60" href="#%60%2A%3D%60"><span>`*=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `*=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#%2A%3D%2CVector%5BT%5D%2Cfloat">utils: proc `*=`[T](v1: var Vector[T]; d: float)</a></li>
          </ul></dd>
<dt><a name="%60%2A%60" href="#%60%2A%60"><span>`*`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[float]; t2: Tensor[T]): Tensor[T]" href="numericalnim/private/arraymancerOverloads.html#%2A%2CTensor%5Bfloat%5D%2CTensor%5BT%3A%20not%20SomeNumber%5D">arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[float]; t2: Tensor[T]): Tensor[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[float]): Tensor[T]" href="numericalnim/private/arraymancerOverloads.html#%2A%2CTensor%5BT%3A%20not%20SomeNumber%5D%2CTensor%5Bfloat%5D">arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[float]): Tensor[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[T]): Tensor[T]" href="numericalnim/private/arraymancerOverloads.html#%2A%2CTensor%5BT%3A%20not%20SomeNumber%5D%2CTensor%5BT%3A%20not%20SomeNumber%5D">arraymancerOverloads: proc `*`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[T]): Tensor[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `*`[T](d: float; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2A%2Cfloat%2CVector%5BT%5D">utils: proc `*`[T](d: float; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `*`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#%2A%2CVector%5BT%5D%2Cfloat">utils: proc `*`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `*`[T](v1, v2: Vector[T]): float" href="numericalnim/utils.html#%2A%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `*`[T](v1, v2: Vector[T]): float</a></li>
          </ul></dd>
<dt><a name="%60%2B.%3D%60" href="#%60%2B.%3D%60"><span>`+.=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template `+.=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#%2B.%3D.t%2CVector%5BT%5D%2Cfloat">utils: template `+.=`[T](v1: var Vector[T]; d: float)</a></li>
          </ul></dd>
<dt><a name="%60%2B.%60" href="#%60%2B.%60"><span>`+.`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template `+.`[T](d: float; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2B..t%2Cfloat%2CVector%5BT%5D">utils: template `+.`[T](d: float; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: template `+.`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#%2B..t%2CVector%5BT%5D%2Cfloat">utils: template `+.`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60%2B%3D%60" href="#%60%2B%3D%60"><span>`+=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `+=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#%2B%3D%2CVector%5BT%5D%2Cfloat">utils: proc `+=`[T](v1: var Vector[T]; d: float)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+=`[T](v1: var Vector[T]; d: T)" href="numericalnim/utils.html#%2B%3D%2CVector%5BT%5D%2CT">utils: proc `+=`[T](v1: var Vector[T]; d: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+=`[T](v1: var Vector[T]; v2: Vector[T])" href="numericalnim/utils.html#%2B%3D%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `+=`[T](v1: var Vector[T]; v2: Vector[T])</a></li>
          </ul></dd>
<dt><a name="%60%2B%60" href="#%60%2B%60"><span>`+`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="arraymancerOverloads: proc `+`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[T]): Tensor[T]" href="numericalnim/private/arraymancerOverloads.html#%2B%2CTensor%5BT%3A%20not%20SomeNumber%5D%2CTensor%5BT%3A%20not%20SomeNumber%5D">arraymancerOverloads: proc `+`[T: not SomeNumber](t1: Tensor[T]; t2: Tensor[T]): Tensor[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+`[T](d: float; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2B%2Cfloat%2CVector%5BT%5D">utils: proc `+`[T](d: float; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+`[T](d: T; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2B%2CT%2CVector%5BT%5D">utils: proc `+`[T](d: T; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#%2B%2CVector%5BT%5D%2Cfloat">utils: proc `+`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+`[T](v1: Vector[T]; d: T): Vector[T]" href="numericalnim/utils.html#%2B%2CVector%5BT%5D%2CT">utils: proc `+`[T](v1: Vector[T]; d: T): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `+`[T](v1, v2: Vector[T]): Vector[T]" href="numericalnim/utils.html#%2B%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `+`[T](v1, v2: Vector[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60-.%3D%60" href="#%60-.%3D%60"><span>`-.=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template `-.=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#-.%3D.t%2CVector%5BT%5D%2Cfloat">utils: template `-.=`[T](v1: var Vector[T]; d: float)</a></li>
          </ul></dd>
<dt><a name="%60-.%60" href="#%60-.%60"><span>`-.`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template `-.`[T](d: float; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#-..t%2Cfloat%2CVector%5BT%5D">utils: template `-.`[T](d: float; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: template `-.`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#-..t%2CVector%5BT%5D%2Cfloat">utils: template `-.`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60-%3D%60" href="#%60-%3D%60"><span>`-=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `-=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#-%3D%2CVector%5BT%5D%2Cfloat">utils: proc `-=`[T](v1: var Vector[T]; d: float)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-=`[T](v1: var Vector[T]; d: T)" href="numericalnim/utils.html#-%3D%2CVector%5BT%5D%2CT">utils: proc `-=`[T](v1: var Vector[T]; d: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-=`[T](v1: var Vector[T]; v2: Vector[T])" href="numericalnim/utils.html#-%3D%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `-=`[T](v1: var Vector[T]; v2: Vector[T])</a></li>
          </ul></dd>
<dt><a name="%60-%60" href="#%60-%60"><span>`-`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](d: float; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#-%2Cfloat%2CVector%5BT%5D">utils: proc `-`[T](d: float; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](d: T; v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#-%2CT%2CVector%5BT%5D">utils: proc `-`[T](d: T; v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#-%2CVector%5BT%5D">utils: proc `-`[T](v1: Vector[T]): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#-%2CVector%5BT%5D%2Cfloat">utils: proc `-`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](v1: Vector[T]; d: T): Vector[T]" href="numericalnim/utils.html#-%2CVector%5BT%5D%2CT">utils: proc `-`[T](v1: Vector[T]; d: T): Vector[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `-`[T](v1, v2: Vector[T]): Vector[T]" href="numericalnim/utils.html#-%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `-`[T](v1, v2: Vector[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60/.%3D%60" href="#%60/.%3D%60"><span>`/.=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `/.=`[T](v1: var Vector[T]; v2: Vector[T])" href="numericalnim/utils.html#/.%3D%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `/.=`[T](v1: var Vector[T]; v2: Vector[T])</a></li>
          </ul></dd>
<dt><a name="%60/.%60" href="#%60/.%60"><span>`/.`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `/.`[T](v1, v2: Vector[T]): Vector[T]" href="numericalnim/utils.html#/.%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `/.`[T](v1, v2: Vector[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60/%3D%60" href="#%60/%3D%60"><span>`/=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `/=`[T](v1: var Vector[T]; d: float)" href="numericalnim/utils.html#/%3D%2CVector%5BT%5D%2Cfloat">utils: proc `/=`[T](v1: var Vector[T]; d: float)</a></li>
          </ul></dd>
<dt><a name="%60/%60" href="#%60/%60"><span>`/`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `/`[T](v1: Vector[T]; d: float): Vector[T]" href="numericalnim/utils.html#/%2CVector%5BT%5D%2Cfloat">utils: proc `/`[T](v1: Vector[T]; d: float): Vector[T]</a></li>
          </ul></dd>
<dt><a name="%60%3D%3D%60" href="#%60%3D%3D%60"><span>`==`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `==`[T](v1, v2: Vector[T]): bool" href="numericalnim/utils.html#%3D%3D%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc `==`[T](v1, v2: Vector[T]): bool</a></li>
          </ul></dd>
<dt><a name="%60%40%60" href="#%60%40%60"><span>`@`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `@`[T](v: Vector[T]): seq[T]" href="numericalnim/utils.html#%40%2CVector%5BT%5D">utils: proc `@`[T](v: Vector[T]): seq[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `@`[T](v: Vector[Vector[T]]): seq[seq[T]]" href="numericalnim/utils.html#%40%2CVector%5BVector%5BT%5D%5D">utils: proc `@`[T](v: Vector[Vector[T]]): seq[seq[T]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `@`[T](v: Vector[Vector[Vector[T]]]): seq[seq[seq[T]]]" href="numericalnim/utils.html#%40%2CVector%5BVector%5BVector%5BT%5D%5D%5D">utils: proc `@`[T](v: Vector[Vector[Vector[T]]]): seq[seq[seq[T]]]</a></li>
          </ul></dd>
<dt><a name="%60%5B%5D%3D%60" href="#%60%5B%5D%3D%60"><span>`[]=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: proc `[]=`[T; U](ctx: NumContext[T, U]; key: enum; val: T)" href="numericalnim/common/commonTypes.html#%5B%5D%3D%2CNumContext%5BT%2CU%5D%2C%2CT">commonTypes: proc `[]=`[T; U](ctx: NumContext[T, U]; key: enum; val: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="commonTypes: proc `[]=`[T; U](ctx: NumContext[T, U]; key: string; val: T)" href="numericalnim/common/commonTypes.html#%5B%5D%3D%2CNumContext%5BT%2CU%5D%2Cstring%2CT">commonTypes: proc `[]=`[T; U](ctx: NumContext[T, U]; key: string; val: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `[]=`[T](v: var Vector[T]; i: int; value: T)" href="numericalnim/utils.html#%5B%5D%3D%2CVector%5BT%5D%2Cint%2CT">utils: proc `[]=`[T](v: var Vector[T]; i: int; value: T)</a></li>
          </ul></dd>
<dt><a name="%60%5B%5D%60" href="#%60%5B%5D%60"><span>`[]`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: proc `[]`[T; U](ctx: NumContext[T, U]; key: enum): T" href="numericalnim/common/commonTypes.html#%5B%5D%2CNumContext%5BT%2CU%5D%2C">commonTypes: proc `[]`[T; U](ctx: NumContext[T, U]; key: enum): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="commonTypes: proc `[]`[T; U](ctx: NumContext[T, U]; key: string): T" href="numericalnim/common/commonTypes.html#%5B%5D%2CNumContext%5BT%2CU%5D%2Cstring">commonTypes: proc `[]`[T; U](ctx: NumContext[T, U]; key: string): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `[]`[T](v: Vector[T]; i: int): T" href="numericalnim/utils.html#%5B%5D%2CVector%5BT%5D%2Cint">utils: proc `[]`[T](v: Vector[T]; i: int): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `[]`[T](v: var Vector[T]; i: int): var T" href="numericalnim/utils.html#%5B%5D%2CVector%5BT%5D%2Cint_2">utils: proc `[]`[T](v: var Vector[T]; i: int): var T</a></li>
          </ul></dd>
<dt><a name="%60%5E%60" href="#%60%5E%60"><span>`^`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc `^`[float](v: Vector[float]; power: float): Vector[float]" href="numericalnim/utils.html#%5E%2CVector%5Bfloat%5D%2Cfloat">utils: proc `^`[float](v: Vector[float]; power: float): Vector[float]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc `^`[float](v: Vector[float]; power: Natural): Vector[float]" href="numericalnim/utils.html#%5E%2CVector%5Bfloat%5D%2CNatural">utils: proc `^`[float](v: Vector[float]; power: Natural): Vector[float]</a></li>
          </ul></dd>
<dt><a name="abs" href="#abs"><span>abs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc abs[T](v1: Vector[T]): Vector[T]" href="numericalnim/utils.html#abs%2CVector%5BT%5D">utils: proc abs[T](v1: Vector[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="adaptiveGauss" href="#adaptiveGauss"><span>adaptiveGauss:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc adaptiveGauss[T; U](f_in: NumContextProc[T, U]; xStart_in, xEnd_in: U;
                    tol = 1e-8; initialPoints: openArray[U] = @[];
                    maxintervals: int = 10000; ctx: NumContext[T, U] = nil): T" href="numericalnim/integrate.html#adaptiveGauss%2CNumContextProc%5BT%2CU%5D%2CU%2CU%2Cfloat%2CopenArray%5BU%5D%2Cint%2CNumContext%5BT%2CU%5D">integrate: proc adaptiveGauss[T; U](f_in: NumContextProc[T, U]; xStart_in, xEnd_in: U;
                    tol = 1e-8; initialPoints: openArray[U] = @[];
                    maxintervals: int = 10000; ctx: NumContext[T, U] = nil): T</a></li>
          </ul></dd>
<dt><a name="adaptiveGaussLocal" href="#adaptiveGaussLocal"><span>adaptiveGaussLocal:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc adaptiveGaussLocal[T](f: NumContextProc[T, float]; xStart, xEnd: float;
                      tol = 1e-8; ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#adaptiveGaussLocal%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cfloat%2CNumContext%5BT%2Cfloat%5D">integrate: proc adaptiveGaussLocal[T](f: NumContextProc[T, float]; xStart, xEnd: float;
                      tol = 1e-8; ctx: NumContext[T, float] = nil): T</a></li>
          </ul></dd>
<dt><a name="adaptiveODE" href="#adaptiveODE"><span>adaptiveODE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: const adaptiveODE" href="numericalnim/ode.html#adaptiveODE">ode: const adaptiveODE</a></li>
          </ul></dd>
<dt><a name="adaptiveSimpson" href="#adaptiveSimpson"><span>adaptiveSimpson:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc adaptiveSimpson[T](f: NumContextProc[T, float]; xStart, xEnd: float; tol = 1e-8;
                   ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#adaptiveSimpson%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cfloat%2CNumContext%5BT%2Cfloat%5D">integrate: proc adaptiveSimpson[T](f: NumContextProc[T, float]; xStart, xEnd: float; tol = 1e-8;
                   ctx: NumContext[T, float] = nil): T</a></li>
          </ul></dd>
<dt><a name="adaptiveSimpson2" href="#adaptiveSimpson2"><span>adaptiveSimpson2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc adaptiveSimpson2[T](f: NumContextProc[T, float]; xStart, xEnd: float;
                    tol = 1e-8; ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#adaptiveSimpson2%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cfloat%2CNumContext%5BT%2Cfloat%5D">integrate: proc adaptiveSimpson2[T](f: NumContextProc[T, float]; xStart, xEnd: float;
                    tol = 1e-8; ctx: NumContext[T, float] = nil): T</a></li>
          </ul></dd>
<dt><a name="allODE" href="#allODE"><span>allODE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: const allODE" href="numericalnim/ode.html#allODE">ode: const allODE</a></li>
          </ul></dd>
<dt><a name="arange" href="#arange"><span>arange:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc arange(x1, x2, dx: float; includeStart = true; includeEnd = false): seq[float]" href="numericalnim/utils.html#arange%2Cfloat%2Cfloat%2Cfloat">utils: proc arange(x1, x2, dx: float; includeStart = true; includeEnd = false): seq[float]</a></li>
          </ul></dd>
<dt><a name="Armijo" href="#Armijo"><span>Armijo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: LineSearchCriterion.Armijo" href="numericalnim/optimize.html#Armijo">optimize: LineSearchCriterion.Armijo</a></li>
          </ul></dd>
<dt><a name="benchmarkit" href="#benchmarkit"><span>benchmarkit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template benchmarkit[T](s: untyped; n = 100; msg = &quot;&quot;; answer: T; onlyEfficiency = false): untyped" href="numericalnim/utils.html#benchmarkit.t%2Cuntyped%2Cint%2Cstring%2CT">utils: template benchmarkit[T](s: untyped; n = 100; msg = &quot;&quot;; answer: T; onlyEfficiency = false): untyped</a></li>
          </ul></dd>
<dt><a name="bfgs" href="#bfgs"><span>bfgs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc bfgs[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, StandardOptions] = bfgsOptions[U]();
                       analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]" href="numericalnim/optimize.html#bfgs%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2COptimOptions%5BU%2CStandardOptions%5D%2Cproc%28Tensor%5BU%5D%29">optimize: proc bfgs[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, StandardOptions] = bfgsOptions[U]();
                       analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]</a></li>
          </ul></dd>
<dt><a name="bfgs_old" href="#bfgs_old"><span>bfgs_old:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc bfgs_old[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                           alpha: U = U(1); tol: U = U(0.000001);
                           fastMode: bool = false; analyticGradient: proc (
    x: Tensor[U]): Tensor[T] = nil): Tensor[U]" href="numericalnim/optimize.html#bfgs_old%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CU%2CU%2Cbool%2Cproc%28Tensor%5BU%5D%29">optimize: proc bfgs_old[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                           alpha: U = U(1); tol: U = U(0.000001);
                           fastMode: bool = false; analyticGradient: proc (
    x: Tensor[U]): Tensor[T] = nil): Tensor[U]</a></li>
          </ul></dd>
<dt><a name="bfgsOptions" href="#bfgsOptions"><span>bfgsOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc bfgsOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
               maxIterations: int = 10000;
               lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]" href="numericalnim/optimize.html#bfgsOptions%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc bfgsOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
               maxIterations: int = 10000;
               lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]</a></li>
          </ul></dd>
<dt><a name="calcError" href="#calcError"><span>calcError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc calcError[T](y_true, y: T): auto" href="numericalnim/utils.html#calcError%2CT%2CT">utils: proc calcError[T](y_true, y: T): auto</a></li>
          </ul></dd>
<dt><a name="checkGradient" href="#checkGradient"><span>checkGradient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc checkGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T;
                                fGrad: proc (x: Tensor[U]): Tensor[T];
                                x0: Tensor[U]; tol: T): bool" href="numericalnim/differentiate.html#checkGradient%2Cproc%28Tensor%5BU%5D%29%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CT">differentiate: proc checkGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T;
                                fGrad: proc (x: Tensor[U]): Tensor[T];
                                x0: Tensor[U]; tol: T): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="differentiate: proc checkGradient[U; T](f: proc (x: Tensor[U]): Tensor[T];
                    fGrad: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U]; tol: T): bool" href="numericalnim/differentiate.html#checkGradient%2Cproc%28Tensor%5BU%5D%29%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CT_2">differentiate: proc checkGradient[U; T](f: proc (x: Tensor[U]): Tensor[T];
                    fGrad: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U]; tol: T): bool</a></li>
          </ul></dd>
<dt><a name="checkVectorSizes" href="#checkVectorSizes"><span>checkVectorSizes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc checkVectorSizes(v1, v2: Vector)" href="numericalnim/utils.html#checkVectorSizes%2CVector%2CVector">utils: proc checkVectorSizes(v1, v2: Vector)</a></li>
          </ul></dd>
<dt><a name="chi2" href="#chi2"><span>chi2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc chi2[T](yData, yFit, yError: seq[T] or Tensor[T]): T" href="numericalnim/utils.html#chi2%2C%2C%2C">utils: proc chi2[T](yData, yFit, yError: seq[T] or Tensor[T]): T</a></li>
          </ul></dd>
<dt><a name="clone" href="#clone"><span>clone:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc clone[T](x: T): T" href="numericalnim/utils.html#clone%2CT">utils: proc clone[T](x: T): T</a></li>
          </ul></dd>
<dt><a name="cmpInterval" href="#cmpInterval"><span>cmpInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc cmpInterval[T; U; V](interval1, interval2: IntervalType[T, U, V]): int" href="numericalnim/integrate.html#cmpInterval%2CIntervalType%5BT%2CU%2CV%5D%2CIntervalType%5BT%2CU%2CV%5D">integrate: proc cmpInterval[T; U; V](interval1, interval2: IntervalType[T, U, V]): int</a></li>
          </ul></dd>
<dt><a name="compactRbfFunc" href="#compactRbfFunc"><span>compactRbfFunc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc compactRbfFunc(r: Tensor[float]; epsilon: float): Tensor[float]" href="numericalnim/rbf.html#compactRbfFunc%2CTensor%5Bfloat%5D%2Cfloat">rbf: proc compactRbfFunc(r: Tensor[float]; epsilon: float): Tensor[float]</a></li>
          </ul></dd>
<dt><a name="compactRbfFuncScalar" href="#compactRbfFuncScalar"><span>compactRbfFuncScalar:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: template compactRbfFuncScalar(r: float; epsilon: float): float" href="numericalnim/rbf.html#compactRbfFuncScalar.t%2Cfloat%2Cfloat">rbf: template compactRbfFuncScalar(r: float; epsilon: float): float</a></li>
          </ul></dd>
<dt><a name="conjugate_gradient" href="#conjugate_gradient"><span>conjugate_gradient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc conjugate_gradient[T](A, b, x_0: Tensor[T]; tolerance: float64): Tensor[T]" href="numericalnim/optimize.html#conjugate_gradient%2CTensor%5BT%5D%2CTensor%5BT%5D%2CTensor%5BT%5D%2Cfloat64">optimize: proc conjugate_gradient[T](A, b, x_0: Tensor[T]; tolerance: float64): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="Constant" href="#Constant"><span>Constant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: ExtrapolateKind.Constant" href="numericalnim/interpolate.html#Constant">interpolate: ExtrapolateKind.Constant</a></li>
          </ul></dd>
<dt><a name="constructMeshedPatches" href="#constructMeshedPatches"><span>constructMeshedPatches:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc constructMeshedPatches[T](grid: RbfGrid[T]): Tensor[float]" href="numericalnim/rbf.html#constructMeshedPatches%2CRbfGrid%5BT%5D">rbf: proc constructMeshedPatches[T](grid: RbfGrid[T]): Tensor[float]</a></li>
          </ul></dd>
<dt><a name="cumGauss" href="#cumGauss"><span>cumGauss:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc cumGauss[T](f_in: NumContextProc[T, float]; X: openArray[float]; tol = 1e-8;
            initialPoints: openArray[float] = @[]; maxintervals: int = 10000;
            ctx: NumContext[T, float] = nil): seq[T]" href="numericalnim/integrate.html#cumGauss%2CNumContextProc%5BT%2Cfloat%5D%2CopenArray%5Bfloat%5D%2Cfloat%2CopenArray%5Bfloat%5D%2Cint%2CNumContext%5BT%2Cfloat%5D">integrate: proc cumGauss[T](f_in: NumContextProc[T, float]; X: openArray[float]; tol = 1e-8;
            initialPoints: openArray[float] = @[]; maxintervals: int = 10000;
            ctx: NumContext[T, float] = nil): seq[T]</a></li>
          </ul></dd>
<dt><a name="cumGaussSpline" href="#cumGaussSpline"><span>cumGaussSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc cumGaussSpline[T; U](f_in: NumContextProc[T, U]; xStart_in, xEnd_in: U;
                     tol = 1e-8; initialPoints: openArray[U] = @[];
                     maxintervals: int = 10000; ctx: NumContext[T, U] = nil): InterpolatorType[
    T]" href="numericalnim/integrate.html#cumGaussSpline%2CNumContextProc%5BT%2CU%5D%2CU%2CU%2Cfloat%2CopenArray%5BU%5D%2Cint%2CNumContext%5BT%2CU%5D">integrate: proc cumGaussSpline[T; U](f_in: NumContextProc[T, U]; xStart_in, xEnd_in: U;
                     tol = 1e-8; initialPoints: openArray[U] = @[];
                     maxintervals: int = 10000; ctx: NumContext[T, U] = nil): InterpolatorType[
    T]</a></li>
          </ul></dd>
<dt><a name="cumsimpson" href="#cumsimpson"><span>cumsimpson:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc cumsimpson[T](f: NumContextProc[T, float]; X: openArray[float];
              ctx: NumContext[T, float] = nil; dx = 0.00001): seq[T]" href="numericalnim/integrate.html#cumsimpson%2CNumContextProc%5BT%2Cfloat%5D%2CopenArray%5Bfloat%5D%2CNumContext%5BT%2Cfloat%5D%2Cfloat">integrate: proc cumsimpson[T](f: NumContextProc[T, float]; X: openArray[float];
              ctx: NumContext[T, float] = nil; dx = 0.00001): seq[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="integrate: proc cumsimpson[T](Y: openArray[T]; X: openArray[float]): seq[T]" href="numericalnim/integrate.html#cumsimpson%2CopenArray%5BT%5D%2CopenArray%5Bfloat%5D">integrate: proc cumsimpson[T](Y: openArray[T]; X: openArray[float]): seq[T]</a></li>
          </ul></dd>
<dt><a name="cumtrapz" href="#cumtrapz"><span>cumtrapz:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc cumtrapz[T](f: NumContextProc[T, float]; X: openArray[float];
            ctx: NumContext[T, float] = nil; dx = 0.00001): seq[T]" href="numericalnim/integrate.html#cumtrapz%2CNumContextProc%5BT%2Cfloat%5D%2CopenArray%5Bfloat%5D%2CNumContext%5BT%2Cfloat%5D%2Cfloat">integrate: proc cumtrapz[T](f: NumContextProc[T, float]; X: openArray[float];
            ctx: NumContext[T, float] = nil; dx = 0.00001): seq[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="integrate: proc cumtrapz[T](Y: openArray[T]; X: openArray[float]): seq[T]" href="numericalnim/integrate.html#cumtrapz%2CopenArray%5BT%5D%2CopenArray%5Bfloat%5D">integrate: proc cumtrapz[T](Y: openArray[T]; X: openArray[float]): seq[T]</a></li>
          </ul></dd>
<dt><a name="delete" href="#delete"><span>delete:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc delete[T](s: var seq[T]; idx: seq[int])" href="numericalnim/utils.html#delete%2Cseq%5BT%5D%2Cseq%5Bint%5D">utils: proc delete[T](s: var seq[T]; idx: seq[int])</a></li>
          </ul></dd>
<dt><a name="derivEval" href="#derivEval"><span>derivEval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc derivEval[T; U](interpolator: InterpolatorType[T]; x: float;
                extrap: ExtrapolateKind = Native; extrapValue: U = missing()): T" href="numericalnim/interpolate.html#derivEval%2CInterpolatorType%5BT%5D%2Cfloat%2CExtrapolateKind%2CU">interpolate: proc derivEval[T; U](interpolator: InterpolatorType[T]; x: float;
                extrap: ExtrapolateKind = Native; extrapValue: U = missing()): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: proc derivEval[T; U](spline: InterpolatorType[T]; x: openArray[float];
                extrap: ExtrapolateKind = Native; extrapValue: U = missing()): seq[
    T]" href="numericalnim/interpolate.html#derivEval%2CInterpolatorType%5BT%5D%2CopenArray%5Bfloat%5D%2CExtrapolateKind%2CU">interpolate: proc derivEval[T; U](spline: InterpolatorType[T]; x: openArray[float];
                extrap: ExtrapolateKind = Native; extrapValue: U = missing()): seq[
    T]</a></li>
          </ul></dd>
<dt><a name="derivEval_cubicspline" href="#derivEval_cubicspline"><span>derivEval_cubicspline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc derivEval_cubicspline[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#derivEval_cubicspline%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc derivEval_cubicspline[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="derivEval_hermitespline" href="#derivEval_hermitespline"><span>derivEval_hermitespline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc derivEval_hermitespline[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#derivEval_hermitespline%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc derivEval_hermitespline[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="derivEval_linear1d" href="#derivEval_linear1d"><span>derivEval_linear1d:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc derivEval_linear1d[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#derivEval_linear1d%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc derivEval_linear1d[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="diff1dBackward" href="#diff1dBackward"><span>diff1dBackward:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc diff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#diff1dBackward%2Cproc%28U%29%2CU%2CU">differentiate: proc diff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="diff1dCentral" href="#diff1dCentral"><span>diff1dCentral:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc diff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#diff1dCentral%2Cproc%28U%29%2CU%2CU">differentiate: proc diff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="diff1dForward" href="#diff1dForward"><span>diff1dForward:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc diff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#diff1dForward%2Cproc%28U%29%2CU%2CU">differentiate: proc diff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="dot" href="#dot"><span>dot:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="arraymancerOverloads: proc dot[T: not SomeNumber](t1: Tensor[float]; t2: Tensor[T]): T" href="numericalnim/private/arraymancerOverloads.html#dot%2CTensor%5Bfloat%5D%2CTensor%5BT%3A%20not%20SomeNumber%5D">arraymancerOverloads: proc dot[T: not SomeNumber](t1: Tensor[float]; t2: Tensor[T]): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc dot[T](v1, v2: Vector[T]): float" href="numericalnim/utils.html#dot%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc dot[T](v1, v2: Vector[T]): float</a></li>
          </ul></dd>
<dt><a name="Edge" href="#Edge"><span>Edge:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: ExtrapolateKind.Edge" href="numericalnim/interpolate.html#Edge">interpolate: ExtrapolateKind.Edge</a></li>
          </ul></dd>
<dt><a name="Error" href="#Error"><span>Error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: ExtrapolateKind.Error" href="numericalnim/interpolate.html#Error">interpolate: ExtrapolateKind.Error</a></li>
          </ul></dd>
<dt><a name="eval" href="#eval"><span>eval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval[T; U](interpolator: InterpolatorType[T]; x: float;
           extrap: ExtrapolateKind = Native; extrapValue: U = missing()): T" href="numericalnim/interpolate.html#eval%2CInterpolatorType%5BT%5D%2Cfloat%2CExtrapolateKind%2CU">interpolate: proc eval[T; U](interpolator: InterpolatorType[T]; x: float;
           extrap: ExtrapolateKind = Native; extrapValue: U = missing()): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval[T; U](spline: InterpolatorType[T]; x: openArray[float];
           extrap: ExtrapolateKind = Native; extrapValue: U = missing()): seq[T]" href="numericalnim/interpolate.html#eval%2CInterpolatorType%5BT%5D%2CopenArray%5Bfloat%5D%2CExtrapolateKind%2CU">interpolate: proc eval[T; U](spline: InterpolatorType[T]; x: openArray[float];
           extrap: ExtrapolateKind = Native; extrapValue: U = missing()): seq[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: template eval[T](interpolator: Interpolator2DType[T]; x, y: float): untyped" href="numericalnim/interpolate.html#eval.t%2CInterpolator2DType%5BT%5D%2Cfloat%2Cfloat">interpolate: template eval[T](interpolator: Interpolator2DType[T]; x, y: float): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: template eval[T](interpolator: Interpolator3DType[T]; x, y, z: float): untyped" href="numericalnim/interpolate.html#eval.t%2CInterpolator3DType%5BT%5D%2Cfloat%2Cfloat%2Cfloat">interpolate: template eval[T](interpolator: Interpolator3DType[T]; x, y, z: float): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: template eval[T, U](interpolator: InterpolatorUnstructured2DType[T, U]; x, y: T): untyped" href="numericalnim/interpolate.html#eval.t%2CInterpolatorUnstructured2DType%5BT%2CU%5D%2CT%2CT">interpolate: template eval[T, U](interpolator: InterpolatorUnstructured2DType[T, U]; x, y: T): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rbf: proc eval[T](rbf: RbfBaseType[T]; x: Tensor[float]): Tensor[T]" href="numericalnim/rbf.html#eval%2CRbfBaseType%5BT%5D%2CTensor%5Bfloat%5D">rbf: proc eval[T](rbf: RbfBaseType[T]; x: Tensor[float]): Tensor[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rbf: proc eval[T](rbf: RbfType[T]; x: Tensor[float]): Tensor[T]" href="numericalnim/rbf.html#eval%2CRbfType%5BT%5D%2CTensor%5Bfloat%5D">rbf: proc eval[T](rbf: RbfType[T]; x: Tensor[float]): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="Eval2DHandler" href="#Eval2DHandler"><span>Eval2DHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type Eval2DHandler" href="numericalnim/interpolate.html#Eval2DHandler">interpolate: type Eval2DHandler</a></li>
          </ul></dd>
<dt><a name="Eval3DHandler" href="#Eval3DHandler"><span>Eval3DHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type Eval3DHandler" href="numericalnim/interpolate.html#Eval3DHandler">interpolate: type Eval3DHandler</a></li>
          </ul></dd>
<dt><a name="evalAlt" href="#evalAlt"><span>evalAlt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc evalAlt[T](rbf: RbfType[T]; x: Tensor[float]): Tensor[T]" href="numericalnim/rbf.html#evalAlt%2CRbfType%5BT%5D%2CTensor%5Bfloat%5D">rbf: proc evalAlt[T](rbf: RbfType[T]; x: Tensor[float]): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="eval_barycentric2d" href="#eval_barycentric2d"><span>eval_barycentric2d:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_barycentric2d[T, U](self: InterpolatorUnstructured2DType[T, U]; x, y: float): U" href="numericalnim/interpolate.html#eval_barycentric2d%2CInterpolatorUnstructured2DType%5BT%2CU%5D%2Cfloat%2Cfloat">interpolate: proc eval_barycentric2d[T, U](self: InterpolatorUnstructured2DType[T, U]; x, y: float): U</a></li>
          </ul></dd>
<dt><a name="eval_bicubic" href="#eval_bicubic"><span>eval_bicubic:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_bicubic[T](self: Interpolator2DType[T]; x, y: float): T" href="numericalnim/interpolate.html#eval_bicubic%2CInterpolator2DType%5BT%5D%2Cfloat%2Cfloat">interpolate: proc eval_bicubic[T](self: Interpolator2DType[T]; x, y: float): T</a></li>
          </ul></dd>
<dt><a name="eval_bilinear" href="#eval_bilinear"><span>eval_bilinear:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_bilinear[T](self: Interpolator2DType[T]; x, y: float): T" href="numericalnim/interpolate.html#eval_bilinear%2CInterpolator2DType%5BT%5D%2Cfloat%2Cfloat">interpolate: proc eval_bilinear[T](self: Interpolator2DType[T]; x, y: float): T</a></li>
          </ul></dd>
<dt><a name="eval_cubicspline" href="#eval_cubicspline"><span>eval_cubicspline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_cubicspline[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#eval_cubicspline%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc eval_cubicspline[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="EvalHandler" href="#EvalHandler"><span>EvalHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type EvalHandler" href="numericalnim/interpolate.html#EvalHandler">interpolate: type EvalHandler</a></li>
          </ul></dd>
<dt><a name="eval_hermitespline" href="#eval_hermitespline"><span>eval_hermitespline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_hermitespline[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#eval_hermitespline%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc eval_hermitespline[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="eval_linear1d" href="#eval_linear1d"><span>eval_linear1d:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_linear1d[T](spline: InterpolatorType[T]; x: float): T" href="numericalnim/interpolate.html#eval_linear1d%2CInterpolatorType%5BT%5D%2Cfloat">interpolate: proc eval_linear1d[T](spline: InterpolatorType[T]; x: float): T</a></li>
          </ul></dd>
<dt><a name="eval_nearestneigh" href="#eval_nearestneigh"><span>eval_nearestneigh:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_nearestneigh[T](self: Interpolator2DType[T]; x, y: float): T" href="numericalnim/interpolate.html#eval_nearestneigh%2CInterpolator2DType%5BT%5D%2Cfloat%2Cfloat">interpolate: proc eval_nearestneigh[T](self: Interpolator2DType[T]; x, y: float): T</a></li>
          </ul></dd>
<dt><a name="eval_trilinear" href="#eval_trilinear"><span>eval_trilinear:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc eval_trilinear[T](self: Interpolator3DType[T]; x, y, z: float): T" href="numericalnim/interpolate.html#eval_trilinear%2CInterpolator3DType%5BT%5D%2Cfloat%2Cfloat%2Cfloat">interpolate: proc eval_trilinear[T](self: Interpolator3DType[T]; x, y, z: float): T</a></li>
          </ul></dd>
<dt><a name="EvalUnstructured2DHandler" href="#EvalUnstructured2DHandler"><span>EvalUnstructured2DHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type EvalUnstructured2DHandler" href="numericalnim/interpolate.html#EvalUnstructured2DHandler">interpolate: type EvalUnstructured2DHandler</a></li>
          </ul></dd>
<dt><a name="ExtrapolateKind" href="#ExtrapolateKind"><span>ExtrapolateKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: enum ExtrapolateKind" href="numericalnim/interpolate.html#ExtrapolateKind">interpolate: enum ExtrapolateKind</a></li>
          </ul></dd>
<dt><a name="findAllBetween" href="#findAllBetween"><span>findAllBetween:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc findAllBetween[T](grid: RbfGrid[T]; x: Tensor[float]; rho1, rho2: float): seq[
    int]" href="numericalnim/rbf.html#findAllBetween%2CRbfGrid%5BT%5D%2CTensor%5Bfloat%5D%2Cfloat%2Cfloat">rbf: proc findAllBetween[T](grid: RbfGrid[T]; x: Tensor[float]; rho1, rho2: float): seq[
    int]</a></li>
          </ul></dd>
<dt><a name="findAllWithin" href="#findAllWithin"><span>findAllWithin:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc findAllWithin[T](grid: RbfGrid[T]; x: Tensor[float]; rho: float): seq[int]" href="numericalnim/rbf.html#findAllWithin%2CRbfGrid%5BT%5D%2CTensor%5Bfloat%5D%2Cfloat">rbf: proc findAllWithin[T](grid: RbfGrid[T]; x: Tensor[float]; rho: float): seq[int]</a></li>
          </ul></dd>
<dt><a name="findDuplicates" href="#findDuplicates"><span>findDuplicates:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc findDuplicates[T](x: openArray[T]; isSorted: bool = false): seq[seq[int]]" href="numericalnim/utils.html#findDuplicates%2CopenArray%5BT%5D%2Cbool">utils: proc findDuplicates[T](x: openArray[T]; isSorted: bool = false): seq[seq[int]]</a></li>
          </ul></dd>
<dt><a name="findIndex" href="#findIndex"><span>findIndex:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc findIndex[T](grid: RbfGrid[T]; point: Tensor[float]): int" href="numericalnim/rbf.html#findIndex%2CRbfGrid%5BT%5D%2CTensor%5Bfloat%5D">rbf: proc findIndex[T](grid: RbfGrid[T]; point: Tensor[float]): int</a></li>
          </ul></dd>
<dt><a name="findInterval" href="#findInterval"><span>findInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc findInterval(list: openArray[float]; x: float): int" href="numericalnim/interpolate.html#findInterval%2CopenArray%5Bfloat%5D%2Cfloat">interpolate: proc findInterval(list: openArray[float]; x: float): int</a></li>
          </ul></dd>
<dt><a name="fixedODE" href="#fixedODE"><span>fixedODE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: const fixedODE" href="numericalnim/ode.html#fixedODE">ode: const fixedODE</a></li>
          </ul></dd>
<dt><a name="gaussQuad" href="#gaussQuad"><span>gaussQuad:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc gaussQuad[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 100;
             nPoints = 7; ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#gaussQuad%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cint%2Cint%2CNumContext%5BT%2Cfloat%5D">integrate: proc gaussQuad[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 100;
             nPoints = 7; ctx: NumContext[T, float] = nil): T</a></li>
          </ul></dd>
<dt><a name="getF" href="#getF"><span>getF:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: proc getF[T; U](ctx: NumContext[T, U]; key: enum): U" href="numericalnim/common/commonTypes.html#getF%2CNumContext%5BT%2CU%5D%2C">commonTypes: proc getF[T; U](ctx: NumContext[T, U]; key: enum): U</a></li>
          <li><a class="reference external"
          data-doc-search-tag="commonTypes: proc getF[T; U](ctx: NumContext[T, U]; key: string): U" href="numericalnim/common/commonTypes.html#getF%2CNumContext%5BT%2CU%5D%2Cstring">commonTypes: proc getF[T; U](ctx: NumContext[T, U]; key: string): U</a></li>
          </ul></dd>
<dt><a name="getIndexTable" href="#getIndexTable"><span>getIndexTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc getIndexTable[T](x: openArray[T]): Table[T, seq[int]]" href="numericalnim/utils.html#getIndexTable%2CopenArray%5BT%5D">utils: proc getIndexTable[T](x: openArray[T]): Table[T, seq[int]]</a></li>
          </ul></dd>
<dt><a name="hermiteInterpolate" href="#hermiteInterpolate"><span>hermiteInterpolate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc hermiteInterpolate[T](x: openArray[float]; t: openArray[float];
                      y, dy: openArray[T]): seq[T]" href="numericalnim/utils.html#hermiteInterpolate%2CopenArray%5Bfloat%5D%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D%2CopenArray%5BT%5D">utils: proc hermiteInterpolate[T](x: openArray[float]; t: openArray[float];
                      y, dy: openArray[T]): seq[T]</a></li>
          </ul></dd>
<dt><a name="hermiteSpline" href="#hermiteSpline"><span>hermiteSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc hermiteSpline[T](x, x1, x2: float; y1, y2, dy1, dy2: T): T" href="numericalnim/utils.html#hermiteSpline%2Cfloat%2Cfloat%2Cfloat%2CT%2CT%2CT%2CT">utils: proc hermiteSpline[T](x, x1, x2: float; y1, y2, dy1, dy2: T): T</a></li>
          </ul></dd>
<dt><a name="insert" href="#insert"><span>insert:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc insert[T; U; V](intervalList: var IntervalList[T, U, V];
                el: IntervalType[T, U, V])" href="numericalnim/integrate.html#insert%2CIntervalList%5BT%2CU%2CV%5D%2CIntervalType%5BT%2CU%2CV%5D">integrate: proc insert[T; U; V](intervalList: var IntervalList[T, U, V];
                el: IntervalType[T, U, V])</a></li>
          </ul></dd>
<dt><a name="IntegratorProc" href="#IntegratorProc"><span>IntegratorProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: type IntegratorProc" href="numericalnim/ode.html#IntegratorProc">ode: type IntegratorProc</a></li>
          </ul></dd>
<dt><a name="Interpolator2DType" href="#Interpolator2DType"><span>Interpolator2DType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type Interpolator2DType" href="numericalnim/interpolate.html#Interpolator2DType">interpolate: type Interpolator2DType</a></li>
          </ul></dd>
<dt><a name="Interpolator3DType" href="#Interpolator3DType"><span>Interpolator3DType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type Interpolator3DType" href="numericalnim/interpolate.html#Interpolator3DType">interpolate: type Interpolator3DType</a></li>
          </ul></dd>
<dt><a name="InterpolatorProc" href="#InterpolatorProc"><span>InterpolatorProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: type InterpolatorProc" href="numericalnim/common/commonTypes.html#InterpolatorProc">commonTypes: type InterpolatorProc</a></li>
          </ul></dd>
<dt><a name="InterpolatorType" href="#InterpolatorType"><span>InterpolatorType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type InterpolatorType" href="numericalnim/interpolate.html#InterpolatorType">interpolate: type InterpolatorType</a></li>
          </ul></dd>
<dt><a name="InterpolatorUnstructured2DType" href="#InterpolatorUnstructured2DType"><span>InterpolatorUnstructured2DType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: type InterpolatorUnstructured2DType" href="numericalnim/interpolate.html#InterpolatorUnstructured2DType">interpolate: type InterpolatorUnstructured2DType</a></li>
          </ul></dd>
<dt><a name="isClose" href="#isClose"><span>isClose:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc isClose[T](y1, y2: T; tol: float = 0.001): bool" href="numericalnim/utils.html#isClose%2CT%2CT%2Cfloat">utils: proc isClose[T](y1, y2: T; tol: float = 0.001): bool</a></li>
          </ul></dd>
<dt><a name="items" href="#items"><span>items:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: iterator items[T](v: Vector[T]): T" href="numericalnim/utils.html#items.i%2CVector%5BT%5D">utils: iterator items[T](v: Vector[T]): T</a></li>
          </ul></dd>
<dt><a name="lbfgs" href="#lbfgs"><span>lbfgs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc lbfgs[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, LBFGSOptions[U]] = lbfgsOptions[U]();
                        analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]" href="numericalnim/optimize.html#lbfgs%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2COptimOptions%5BU%2CLBFGSOptions%5BU%5D%5D%2Cproc%28Tensor%5BU%5D%29">optimize: proc lbfgs[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, LBFGSOptions[U]] = lbfgsOptions[U]();
                        analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]</a></li>
          </ul></dd>
<dt><a name="LBFGSOptions" href="#LBFGSOptions"><span>LBFGSOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: object LBFGSOptions" href="numericalnim/optimize.html#LBFGSOptions">optimize: object LBFGSOptions</a></li>
          </ul></dd>
<dt><a name="lbfgsOptions" href="#lbfgsOptions"><span>lbfgsOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc lbfgsOptions[U](savedIterations: int = 10; tol: U = U(0.000001);
                alpha: U = U(1); fastMode: bool = false;
                maxIterations: int = 10000;
                lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, LBFGSOptions[U]]" href="numericalnim/optimize.html#lbfgsOptions%2Cint%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc lbfgsOptions[U](savedIterations: int = 10; tol: U = U(0.000001);
                alpha: U = U(1); fastMode: bool = false;
                maxIterations: int = 10000;
                lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, LBFGSOptions[U]]</a></li>
          </ul></dd>
<dt><a name="levmarq" href="#levmarq"><span>levmarq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc levmarq[U; T: not Tensor](f: proc (params: Tensor[U]; x: U): T;
                          params0: Tensor[U]; xData: Tensor[U];
                          yData: Tensor[T]; options: OptimOptions[U,
    LevMarqOptions[U]] = levmarqOptions[U]();
                          yError: Tensor[T] = ones_like(yData)): Tensor[U]" href="numericalnim/optimize.html#levmarq%2Cproc%28Tensor%5BU%5D%2CU%29%2CTensor%5BU%5D%2CTensor%5BU%5D%2CTensor%5BT%3A%20not%20Tensor%5D%2COptimOptions%5BU%2CLevMarqOptions%5BU%5D%5D%2CTensor%5BT%3A%20not%20Tensor%5D">optimize: proc levmarq[U; T: not Tensor](f: proc (params: Tensor[U]; x: U): T;
                          params0: Tensor[U]; xData: Tensor[U];
                          yData: Tensor[T]; options: OptimOptions[U,
    LevMarqOptions[U]] = levmarqOptions[U]();
                          yError: Tensor[T] = ones_like(yData)): Tensor[U]</a></li>
          </ul></dd>
<dt><a name="LevMarqOptions" href="#LevMarqOptions"><span>LevMarqOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: object LevMarqOptions" href="numericalnim/optimize.html#LevMarqOptions">optimize: object LevMarqOptions</a></li>
          </ul></dd>
<dt><a name="levmarqOptions" href="#levmarqOptions"><span>levmarqOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc levmarqOptions[U](lambda0: U = U(1); tol: U = U(0.000001); alpha: U = U(1);
                  fastMode: bool = false; maxIterations: int = 10000;
                  lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, LevMarqOptions[U]]" href="numericalnim/optimize.html#levmarqOptions%2CU%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc levmarqOptions[U](lambda0: U = U(1); tol: U = U(0.000001); alpha: U = U(1);
                  fastMode: bool = false; maxIterations: int = 10000;
                  lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, LevMarqOptions[U]]</a></li>
          </ul></dd>
<dt><a name="Linear" href="#Linear"><span>Linear:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: ExtrapolateKind.Linear" href="numericalnim/interpolate.html#Linear">interpolate: ExtrapolateKind.Linear</a></li>
          </ul></dd>
<dt><a name="line_search" href="#line_search"><span>line_search:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc line_search[U, T](alpha: var U; p: Tensor[T]; x0: Tensor[U];
                  f: proc (x: Tensor[U]): T; criterion: LineSearchCriterion;
                  fastMode: bool = false)" href="numericalnim/optimize.html#line_search%2CU%2CTensor%5BT%5D%2CTensor%5BU%5D%2Cproc%28Tensor%5BU%5D%29%2CLineSearchCriterion%2Cbool">optimize: proc line_search[U, T](alpha: var U; p: Tensor[T]; x0: Tensor[U];
                  f: proc (x: Tensor[U]): T; criterion: LineSearchCriterion;
                  fastMode: bool = false)</a></li>
          </ul></dd>
<dt><a name="LineSearchCriterion" href="#LineSearchCriterion"><span>LineSearchCriterion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: enum LineSearchCriterion" href="numericalnim/optimize.html#LineSearchCriterion">optimize: enum LineSearchCriterion</a></li>
          </ul></dd>
<dt><a name="linspace" href="#linspace"><span>linspace:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc linspace(x1, x2: float; N: int): seq[float]" href="numericalnim/utils.html#linspace%2Cfloat%2Cfloat%2Cint">utils: proc linspace(x1, x2: float; N: int): seq[float]</a></li>
          </ul></dd>
<dt><a name="mean_squared_error" href="#mean_squared_error"><span>mean_squared_error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc mean_squared_error[T](y_true, y: T): auto" href="numericalnim/utils.html#mean_squared_error%2CT%2CT">utils: proc mean_squared_error[T](y_true, y: T): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc mean_squared_error[T](v1, v2: Vector[T]): float" href="numericalnim/utils.html#mean_squared_error%2CVector%5BT%5D%2CVector%5BT%5D">utils: proc mean_squared_error[T](v1, v2: Vector[T]): float</a></li>
          </ul></dd>
<dt><a name="meshgrid" href="#meshgrid"><span>meshgrid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc meshgrid[T](ts: varargs[Tensor[T]]): Tensor[T]" href="numericalnim/utils.html#meshgrid%2Cvarargs%5BTensor%5BT%5D%5D">utils: proc meshgrid[T](ts: varargs[Tensor[T]]): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="meshgridFlat" href="#meshgridFlat"><span>meshgridFlat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc meshgridFlat[T](x, y: Tensor[T]): (Tensor[T], Tensor[T])" href="numericalnim/utils.html#meshgridFlat%2CTensor%5BT%5D%2CTensor%5BT%5D">utils: proc meshgridFlat[T](x, y: Tensor[T]): (Tensor[T], Tensor[T])</a></li>
          </ul></dd>
<dt><a name="mitems" href="#mitems"><span>mitems:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: iterator mitems[T](v: var Vector[T]): var T" href="numericalnim/utils.html#mitems.i%2CVector%5BT%5D">utils: iterator mitems[T](v: var Vector[T]): var T</a></li>
          </ul></dd>
<dt><a name="mixedDerivative" href="#mixedDerivative"><span>mixedDerivative:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc mixedDerivative[U, T](f: proc (x: Tensor[U]): T; x0: var Tensor[U];
                      indices: (int, int); h: U = U(0.000001)): T" href="numericalnim/differentiate.html#mixedDerivative%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2C%2CU">differentiate: proc mixedDerivative[U, T](f: proc (x: Tensor[U]): T; x0: var Tensor[U];
                      indices: (int, int); h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="Native" href="#Native"><span>Native:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: ExtrapolateKind.Native" href="numericalnim/interpolate.html#Native">interpolate: ExtrapolateKind.Native</a></li>
          </ul></dd>
<dt><a name="neighbours" href="#neighbours"><span>neighbours:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: iterator neighbours[T](grid: RbfGrid[T]; k: int; searchLevels: int = 1): int" href="numericalnim/rbf.html#neighbours.i%2CRbfGrid%5BT%5D%2Cint%2Cint">rbf: iterator neighbours[T](grid: RbfGrid[T]; k: int; searchLevels: int = 1): int</a></li>
          </ul></dd>
<dt><a name="neighboursExcludingCenter" href="#neighboursExcludingCenter"><span>neighboursExcludingCenter:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: iterator neighboursExcludingCenter[T](grid: RbfGrid[T]; k: int): int" href="numericalnim/rbf.html#neighboursExcludingCenter.i%2CRbfGrid%5BT%5D%2Cint">rbf: iterator neighboursExcludingCenter[T](grid: RbfGrid[T]; k: int): int</a></li>
          </ul></dd>
<dt><a name="newBarycentric2D" href="#newBarycentric2D"><span>newBarycentric2D:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newBarycentric2D[T: SomeFloat; U](points: Tensor[T]; values: Tensor[U]): InterpolatorUnstructured2DType[
    T, U]" href="numericalnim/interpolate.html#newBarycentric2D%2CTensor%5BT%3A%20SomeFloat%5D%2CTensor%5BU%5D">interpolate: proc newBarycentric2D[T: SomeFloat; U](points: Tensor[T]; values: Tensor[U]): InterpolatorUnstructured2DType[
    T, U]</a></li>
          </ul></dd>
<dt><a name="newBicubicSpline" href="#newBicubicSpline"><span>newBicubicSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newBicubicSpline[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]" href="numericalnim/interpolate.html#newBicubicSpline%2CTensor%5BT%5D%2C%2C">interpolate: proc newBicubicSpline[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]</a></li>
          </ul></dd>
<dt><a name="newBilinearSpline" href="#newBilinearSpline"><span>newBilinearSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newBilinearSpline[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]" href="numericalnim/interpolate.html#newBilinearSpline%2CTensor%5BT%5D%2C%2C">interpolate: proc newBilinearSpline[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]</a></li>
          </ul></dd>
<dt><a name="newCubicSpline" href="#newCubicSpline"><span>newCubicSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newCubicSpline[T: SomeFloat](X: openArray[float]; Y: openArray[T]): InterpolatorType[
    T]" href="numericalnim/interpolate.html#newCubicSpline%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D">interpolate: proc newCubicSpline[T: SomeFloat](X: openArray[float]; Y: openArray[T]): InterpolatorType[
    T]</a></li>
          </ul></dd>
<dt><a name="newHermiteSpline" href="#newHermiteSpline"><span>newHermiteSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newHermiteSpline[T](X: openArray[float]; Y: openArray[T]): InterpolatorType[T]" href="numericalnim/interpolate.html#newHermiteSpline%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D">interpolate: proc newHermiteSpline[T](X: openArray[float]; Y: openArray[T]): InterpolatorType[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="interpolate: proc newHermiteSpline[T](X: openArray[float]; Y, dY: openArray[T]): InterpolatorType[
    T]" href="numericalnim/interpolate.html#newHermiteSpline%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D%2CopenArray%5BT%5D">interpolate: proc newHermiteSpline[T](X: openArray[float]; Y, dY: openArray[T]): InterpolatorType[
    T]</a></li>
          </ul></dd>
<dt><a name="newLinear1D" href="#newLinear1D"><span>newLinear1D:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newLinear1D[T](X: openArray[float]; Y: openArray[T]): InterpolatorType[T]" href="numericalnim/interpolate.html#newLinear1D%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D">interpolate: proc newLinear1D[T](X: openArray[float]; Y: openArray[T]): InterpolatorType[T]</a></li>
          </ul></dd>
<dt><a name="newNearestNeighbour2D" href="#newNearestNeighbour2D"><span>newNearestNeighbour2D:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newNearestNeighbour2D[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]" href="numericalnim/interpolate.html#newNearestNeighbour2D%2CTensor%5BT%5D%2C%2C">interpolate: proc newNearestNeighbour2D[T](z: Tensor[T]; xlim, ylim: (float, float)): Interpolator2DType[
    T]</a></li>
          </ul></dd>
<dt><a name="newNumContext" href="#newNumContext"><span>newNumContext:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: proc newNumContext[T; U](fValues: Table[string, U] = initTable[string, U]();
                    tValues: Table[string, T] = initTable[string, T]()): NumContext[
    T, U]" href="numericalnim/common/commonTypes.html#newNumContext%2CTable%5Bstring%2CU%5D%2CTable%5Bstring%2CT%5D">commonTypes: proc newNumContext[T; U](fValues: Table[string, U] = initTable[string, U]();
                    tValues: Table[string, T] = initTable[string, T]()): NumContext[
    T, U]</a></li>
          </ul></dd>
<dt><a name="newODEoptions" href="#newODEoptions"><span>newODEoptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: proc newODEoptions(dt: float = 0.0001; absTol: float = 0.0001;
              relTol: float = 0.0001; dtMax: float = 0.01;
              dtMin: float = 0.0001; scaleMax: float = 4.0;
              scaleMin: float = 0.1; tStart: float = 0.0): ODEoptions" href="numericalnim/ode.html#newODEoptions%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat">ode: proc newODEoptions(dt: float = 0.0001; absTol: float = 0.0001;
              relTol: float = 0.0001; dtMax: float = 0.01;
              dtMin: float = 0.0001; scaleMax: float = 4.0;
              scaleMin: float = 0.1; tStart: float = 0.0): ODEoptions</a></li>
          </ul></dd>
<dt><a name="newRbf" href="#newRbf"><span>newRbf:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc newRbf[T](points: Tensor[float]; values: Tensor[T]; gridSize: int = 0;
          rbfFunc: RbfFunc = compactRbfFunc; epsilon: float = 1): RbfType[T]" href="numericalnim/rbf.html#newRbf%2CTensor%5Bfloat%5D%2CTensor%5BT%5D%2Cint%2CRbfFunc%2Cfloat">rbf: proc newRbf[T](points: Tensor[float]; values: Tensor[T]; gridSize: int = 0;
          rbfFunc: RbfFunc = compactRbfFunc; epsilon: float = 1): RbfType[T]</a></li>
          </ul></dd>
<dt><a name="newRbfBase" href="#newRbfBase"><span>newRbfBase:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc newRbfBase[T](points: Tensor[float]; values: Tensor[T];
              rbfFunc: RbfFunc = compactRbfFunc; epsilon: float = 1): RbfBaseType[
    T]" href="numericalnim/rbf.html#newRbfBase%2CTensor%5Bfloat%5D%2CTensor%5BT%5D%2CRbfFunc%2Cfloat">rbf: proc newRbfBase[T](points: Tensor[float]; values: Tensor[T];
              rbfFunc: RbfFunc = compactRbfFunc; epsilon: float = 1): RbfBaseType[
    T]</a></li>
          </ul></dd>
<dt><a name="newRbfGrid" href="#newRbfGrid"><span>newRbfGrid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc newRbfGrid[T](points: Tensor[float]; values: Tensor[T]; gridSize: int = 0): RbfGrid[
    T]" href="numericalnim/rbf.html#newRbfGrid%2CTensor%5Bfloat%5D%2CTensor%5BT%5D%2Cint">rbf: proc newRbfGrid[T](points: Tensor[float]; values: Tensor[T]; gridSize: int = 0): RbfGrid[
    T]</a></li>
          </ul></dd>
<dt><a name="newton" href="#newton"><span>newton:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc newton[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, StandardOptions] = newtonOptions[U]();
                         analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]" href="numericalnim/optimize.html#newton%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2COptimOptions%5BU%2CStandardOptions%5D%2Cproc%28Tensor%5BU%5D%29">optimize: proc newton[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U]; options: OptimOptions[
    U, StandardOptions] = newtonOptions[U]();
                         analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[
    U]</a></li>
          </ul></dd>
<dt><a name="newtonOptions" href="#newtonOptions"><span>newtonOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc newtonOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
                 maxIterations: int = 10000;
                 lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]" href="numericalnim/optimize.html#newtonOptions%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc newtonOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
                 maxIterations: int = 10000;
                 lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]</a></li>
          </ul></dd>
<dt><a name="newtons" href="#newtons"><span>newtons:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc newtons(f: proc (x: float64): float64; deriv: proc (x: float64): float64;
        start: float64; precision: float64 = 0.00001; max_iters: Natural = 1000): float64" href="numericalnim/optimize.html#newtons%2Cproc%28float64%29%2Cproc%28float64%29%2Cfloat64%2Cfloat64%2CNatural">optimize: proc newtons(f: proc (x: float64): float64; deriv: proc (x: float64): float64;
        start: float64; precision: float64 = 0.00001; max_iters: Natural = 1000): float64</a></li>
          </ul></dd>
<dt><a name="newTrilinearSpline" href="#newTrilinearSpline"><span>newTrilinearSpline:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc newTrilinearSpline[T](f: Tensor[T]; xlim, ylim, zlim: (float, float)): Interpolator3DType[
    T]" href="numericalnim/interpolate.html#newTrilinearSpline%2CTensor%5BT%5D%2C%2C%2C">interpolate: proc newTrilinearSpline[T](f: Tensor[T]; xlim, ylim, zlim: (float, float)): Interpolator3DType[
    T]</a></li>
          </ul></dd>
<dt><a name="newVector" href="#newVector"><span>newVector:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc newVector[T](components: openArray[T]): Vector[T]" href="numericalnim/utils.html#newVector%2CopenArray%5BT%5D">utils: proc newVector[T](components: openArray[T]): Vector[T]</a></li>
          </ul></dd>
<dt><a name="NoLineSearch" href="#NoLineSearch"><span>NoLineSearch:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: LineSearchCriterion.NoLineSearch" href="numericalnim/optimize.html#NoLineSearch">optimize: LineSearchCriterion.NoLineSearch</a></li>
          </ul></dd>
<dt><a name="norm" href="#norm"><span>norm:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc norm(v1: Vector; p: int = 2): float64" href="numericalnim/utils.html#norm%2CVector%2Cint">utils: proc norm(v1: Vector; p: int = 2): float64</a></li>
          </ul></dd>
<dt><a name="NumContext" href="#NumContext"><span>NumContext:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: type NumContext" href="numericalnim/common/commonTypes.html#NumContext">commonTypes: type NumContext</a></li>
          </ul></dd>
<dt><a name="NumContextProc" href="#NumContextProc"><span>NumContextProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: type NumContextProc" href="numericalnim/common/commonTypes.html#NumContextProc">commonTypes: type NumContextProc</a></li>
          </ul></dd>
<dt><a name="ODEoptions" href="#ODEoptions"><span>ODEoptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: object ODEoptions" href="numericalnim/ode.html#ODEoptions">ode: object ODEoptions</a></li>
          </ul></dd>
<dt><a name="ODEProc" href="#ODEProc"><span>ODEProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: type ODEProc" href="numericalnim/common/commonTypes.html#ODEProc">commonTypes: type ODEProc</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ode: type ODEProc" href="numericalnim/ode.html#ODEProc">ode: type ODEProc</a></li>
          </ul></dd>
<dt><a name="OptimOptions" href="#OptimOptions"><span>OptimOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: object OptimOptions" href="numericalnim/optimize.html#OptimOptions">optimize: object OptimOptions</a></li>
          </ul></dd>
<dt><a name="optimOptions" href="#optimOptions"><span>optimOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc optimOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
                maxIterations: int = 10000;
                lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]" href="numericalnim/optimize.html#optimOptions%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc optimOptions[U](tol: U = U(0.000001); alpha: U = U(1); fastMode: bool = false;
                maxIterations: int = 10000;
                lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[
    U, StandardOptions]</a></li>
          </ul></dd>
<dt><a name="pairs" href="#pairs"><span>pairs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: iterator pairs[T](v: Vector[T]): (int, T)" href="numericalnim/utils.html#pairs.i%2CVector%5BT%5D">utils: iterator pairs[T](v: Vector[T]): (int, T)</a></li>
          </ul></dd>
<dt><a name="paramUncertainties" href="#paramUncertainties"><span>paramUncertainties:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc paramUncertainties[U; T](params: Tensor[U];
                         fitFunc: proc (params: Tensor[U]; x: U): T;
                         xData: Tensor[U]; yData: Tensor[T]; yError: Tensor[T];
                         returnFullCov = false): Tensor[T]" href="numericalnim/optimize.html#paramUncertainties%2CTensor%5BU%5D%2Cproc%28Tensor%5BU%5D%2CU%29%2CTensor%5BU%5D%2CTensor%5BT%5D%2CTensor%5BT%5D">optimize: proc paramUncertainties[U; T](params: Tensor[U];
                         fitFunc: proc (params: Tensor[U]; x: U): T;
                         xData: Tensor[U]; yData: Tensor[T]; yError: Tensor[T];
                         returnFullCov = false): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="pop" href="#pop"><span>pop:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc pop[T; U; V](intervalList: var IntervalList[T, U, V]): IntervalType[T, U, V]" href="numericalnim/integrate.html#pop%2CIntervalList%5BT%2CU%2CV%5D">integrate: proc pop[T; U; V](intervalList: var IntervalList[T, U, V]): IntervalType[T, U, V]</a></li>
          </ul></dd>
<dt><a name="RbfBaseType" href="#RbfBaseType"><span>RbfBaseType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: object RbfBaseType" href="numericalnim/rbf.html#RbfBaseType">rbf: object RbfBaseType</a></li>
          </ul></dd>
<dt><a name="RbfFunc" href="#RbfFunc"><span>RbfFunc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: type RbfFunc" href="numericalnim/rbf.html#RbfFunc">rbf: type RbfFunc</a></li>
          </ul></dd>
<dt><a name="RbfGrid" href="#RbfGrid"><span>RbfGrid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: object RbfGrid" href="numericalnim/rbf.html#RbfGrid">rbf: object RbfGrid</a></li>
          </ul></dd>
<dt><a name="RbfType" href="#RbfType"><span>RbfType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: object RbfType" href="numericalnim/rbf.html#RbfType">rbf: object RbfType</a></li>
          </ul></dd>
<dt><a name="removeDuplicates" href="#removeDuplicates"><span>removeDuplicates:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc removeDuplicates[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]]): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]" href="numericalnim/utils.html#removeDuplicates%2Cseq%5BTx%5D%2Cseq%5Bseq%5BTy%5D%5D">utils: proc removeDuplicates[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]]): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]</a></li>
          </ul></dd>
<dt><a name="romberg" href="#romberg"><span>romberg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc romberg[T](f: NumContextProc[T, float]; xStart, xEnd: float; depth = 8;
           tol = 1e-8; ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#romberg%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cint%2Cfloat%2CNumContext%5BT%2Cfloat%5D">integrate: proc romberg[T](f: NumContextProc[T, float]; xStart, xEnd: float; depth = 8;
           tol = 1e-8; ctx: NumContext[T, float] = nil): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="integrate: proc romberg[T](Y: openArray[T]; X: openArray[float]): T" href="numericalnim/integrate.html#romberg%2CopenArray%5BT%5D%2CopenArray%5Bfloat%5D">integrate: proc romberg[T](Y: openArray[T]; X: openArray[float]): T</a></li>
          </ul></dd>
<dt><a name="scalePoint" href="#scalePoint"><span>scalePoint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rbf: proc scalePoint(x: Tensor[float];
           limits: tuple[upper: Tensor[float], lower: Tensor[float]]): Tensor[
    float]" href="numericalnim/rbf.html#scalePoint%2CTensor%5Bfloat%5D%2Ctuple%5BTensor%5Bfloat%5D%2CTensor%5Bfloat%5D%5D">rbf: proc scalePoint(x: Tensor[float];
           limits: tuple[upper: Tensor[float], lower: Tensor[float]]): Tensor[
    float]</a></li>
          </ul></dd>
<dt><a name="secant" href="#secant"><span>secant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc secant(f: proc (x: float64): float64; start: array[2, float64];
       precision: float64 = 0.00001; max_iters: Natural = 1000): float64" href="numericalnim/optimize.html#secant%2Cproc%28float64%29%2Carray%5B%2Cfloat64%5D%2Cfloat64%2CNatural">optimize: proc secant(f: proc (x: float64): float64; start: array[2, float64];
       precision: float64 = 0.00001; max_iters: Natural = 1000): float64</a></li>
          </ul></dd>
<dt><a name="secondDiff1dBackward" href="#secondDiff1dBackward"><span>secondDiff1dBackward:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc secondDiff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#secondDiff1dBackward%2Cproc%28U%29%2CU%2CU">differentiate: proc secondDiff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="secondDiff1dCentral" href="#secondDiff1dCentral"><span>secondDiff1dCentral:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc secondDiff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#secondDiff1dCentral%2Cproc%28U%29%2CU%2CU">differentiate: proc secondDiff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="secondDiff1dForward" href="#secondDiff1dForward"><span>secondDiff1dForward:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc secondDiff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T" href="numericalnim/differentiate.html#secondDiff1dForward%2Cproc%28U%29%2CU%2CU">differentiate: proc secondDiff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T</a></li>
          </ul></dd>
<dt><a name="setF" href="#setF"><span>setF:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="commonTypes: proc setF[T; U](ctx: NumContext[T, U]; key: enum; val: U)" href="numericalnim/common/commonTypes.html#setF%2CNumContext%5BT%2CU%5D%2C%2CU">commonTypes: proc setF[T; U](ctx: NumContext[T, U]; key: enum; val: U)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="commonTypes: proc setF[T; U](ctx: NumContext[T, U]; key: string; val: U)" href="numericalnim/common/commonTypes.html#setF%2CNumContext%5BT%2CU%5D%2Cstring%2CU">commonTypes: proc setF[T; U](ctx: NumContext[T, U]; key: string; val: U)</a></li>
          </ul></dd>
<dt><a name="simpson" href="#simpson"><span>simpson:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc simpson[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 500;
           ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#simpson%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cint%2CNumContext%5BT%2Cfloat%5D">integrate: proc simpson[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 500;
           ctx: NumContext[T, float] = nil): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="integrate: proc simpson[T](Y: openArray[T]; X: openArray[float]): T" href="numericalnim/integrate.html#simpson%2CopenArray%5BT%5D%2CopenArray%5Bfloat%5D">integrate: proc simpson[T](Y: openArray[T]; X: openArray[float]): T</a></li>
          </ul></dd>
<dt><a name="size" href="#size"><span>size:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc size[T](v: Vector[T]): int" href="numericalnim/utils.html#size%2CVector%5BT%5D">utils: proc size[T](v: Vector[T]): int</a></li>
          </ul></dd>
<dt><a name="solveODE" href="#solveODE"><span>solveODE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ode: proc solveODE[T](f: ODEProc[T]; y0: T; tspan: openArray[float];
            options: ODEoptions = DEFAULT_ODEoptions;
            ctx: NumContext[T, float] = nil; integrator = &quot;dopri54&quot;): (
    seq[float], seq[T])" href="numericalnim/ode.html#solveODE%2CODEProc%5BT%5D%2CT%2CopenArray%5Bfloat%5D%2CODEoptions%2CNumContext%5BT%2Cfloat%5D%2Cstring">ode: proc solveODE[T](f: ODEProc[T]; y0: T; tspan: openArray[float];
            options: ODEoptions = DEFAULT_ODEoptions;
            ctx: NumContext[T, float] = nil; integrator = &quot;dopri54&quot;): (
    seq[float], seq[T])</a></li>
          </ul></dd>
<dt><a name="sortAndTrimDataset" href="#sortAndTrimDataset"><span>sortAndTrimDataset:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sortAndTrimDataset[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]];
                           sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]" href="numericalnim/utils.html#sortAndTrimDataset%2Cseq%5BTx%5D%2Cseq%5Bseq%5BTy%5D%5D%2CSortOrder">utils: proc sortAndTrimDataset[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]];
                           sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc sortAndTrimDataset[Tx, Ty](x: seq[Tx]; y: seq[Ty];
                           sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[Ty]]" href="numericalnim/utils.html#sortAndTrimDataset%2Cseq%5BTx%5D%2Cseq%5BTy%5D%2CSortOrder">utils: proc sortAndTrimDataset[Tx, Ty](x: seq[Tx]; y: seq[Ty];
                           sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[Ty]]</a></li>
          </ul></dd>
<dt><a name="sortDataset" href="#sortDataset"><span>sortDataset:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sortDataset[T](X: openArray[float]; Y: openArray[T]): seq[(float, T)]" href="numericalnim/utils.html#sortDataset%2CopenArray%5Bfloat%5D%2CopenArray%5BT%5D">utils: proc sortDataset[T](X: openArray[float]; Y: openArray[T]): seq[(float, T)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc sortDataset[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]];
                    sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]" href="numericalnim/utils.html#sortDataset%2Cseq%5BTx%5D%2Cseq%5Bseq%5BTy%5D%5D%2CSortOrder">utils: proc sortDataset[Tx, Ty](x: seq[Tx]; y: seq[seq[Ty]];
                    sortOrder: SortOrder = Ascending): tuple[x: seq[Tx],
    y: seq[seq[Ty]]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utils: proc sortDataset[Tx, Ty](x: seq[Tx]; y: seq[Ty]; sortOrder: SortOrder = Ascending): tuple[
    x: seq[Tx], y: seq[Ty]]" href="numericalnim/utils.html#sortDataset%2Cseq%5BTx%5D%2Cseq%5BTy%5D%2CSortOrder">utils: proc sortDataset[Tx, Ty](x: seq[Tx]; y: seq[Ty]; sortOrder: SortOrder = Ascending): tuple[
    x: seq[Tx], y: seq[Ty]]</a></li>
          </ul></dd>
<dt><a name="StandardOptions" href="#StandardOptions"><span>StandardOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: object StandardOptions" href="numericalnim/optimize.html#StandardOptions">optimize: object StandardOptions</a></li>
          </ul></dd>
<dt><a name="steepest_descent" href="#steepest_descent"><span>steepest_descent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc steepest_descent(deriv: proc (x: float64): float64; start: float64;
                 gamma: float64 = 0.01; precision: float64 = 0.00001;
                 max_iters: Natural = 1000): float64" href="numericalnim/optimize.html#steepest_descent%2Cproc%28float64%29%2Cfloat64%2Cfloat64%2Cfloat64%2CNatural">optimize: proc steepest_descent(deriv: proc (x: float64): float64; start: float64;
                 gamma: float64 = 0.01; precision: float64 = 0.00001;
                 max_iters: Natural = 1000): float64</a></li>
          </ul></dd>
<dt><a name="steepestDescent" href="#steepestDescent"><span>steepestDescent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc steepestDescent[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
    options: OptimOptions[U, StandardOptions] = steepestDescentOptions[U]();
    analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[U]" href="numericalnim/optimize.html#steepestDescent%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2COptimOptions%5BU%2CStandardOptions%5D%2Cproc%28Tensor%5BU%5D%29">optimize: proc steepestDescent[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
    options: OptimOptions[U, StandardOptions] = steepestDescentOptions[U]();
    analyticGradient: proc (x: Tensor[U]): Tensor[T] = nil): Tensor[U]</a></li>
          </ul></dd>
<dt><a name="steepestDescentOptions" href="#steepestDescentOptions"><span>steepestDescentOptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc steepestDescentOptions[U](tol: U = U(0.000001); alpha: U = U(0.001);
                          fastMode: bool = false; maxIterations: int = 10000;
    lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[U,
    StandardOptions]" href="numericalnim/optimize.html#steepestDescentOptions%2CU%2CU%2Cbool%2Cint%2CLineSearchCriterion">optimize: proc steepestDescentOptions[U](tol: U = U(0.000001); alpha: U = U(0.001);
                          fastMode: bool = false; maxIterations: int = 10000;
    lineSearchCriterion: LineSearchCriterion = NoLineSearch): OptimOptions[U,
    StandardOptions]</a></li>
          </ul></dd>
<dt><a name="sum" href="#sum"><span>sum:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sum[T](v: Vector[T]): T" href="numericalnim/utils.html#sum%2CVector%5BT%5D">utils: proc sum[T](v: Vector[T]): T</a></li>
          </ul></dd>
<dt><a name="tensorGradient" href="#tensorGradient"><span>tensorGradient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc tensorGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                                 h: U = U(0.000001); fastMode: bool = false): Tensor[
    T]" href="numericalnim/differentiate.html#tensorGradient%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CU%2Cbool">differentiate: proc tensorGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                                 h: U = U(0.000001); fastMode: bool = false): Tensor[
    T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="differentiate: proc tensorGradient[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];
                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]" href="numericalnim/differentiate.html#tensorGradient%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CU%2Cbool_2">differentiate: proc tensorGradient[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];
                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="tensorHessian" href="#tensorHessian"><span>tensorHessian:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc tensorHessian[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                                h: U = U(0.000001)): Tensor[T]" href="numericalnim/differentiate.html#tensorHessian%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CU">differentiate: proc tensorHessian[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];
                                h: U = U(0.000001)): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="tensorJacobian" href="#tensorJacobian"><span>tensorJacobian:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="differentiate: proc tensorJacobian[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];
                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]" href="numericalnim/differentiate.html#tensorJacobian%2Cproc%28Tensor%5BU%5D%29%2CTensor%5BU%5D%2CU%2Cbool">differentiate: proc tensorJacobian[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];
                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]</a></li>
          </ul></dd>
<dt><a name="timeit" href="#timeit"><span>timeit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: template timeit(s: untyped; n = 100; msg = &quot;&quot;): untyped" href="numericalnim/utils.html#timeit.t%2Cuntyped%2Cint%2Cstring">utils: template timeit(s: untyped; n = 100; msg = &quot;&quot;): untyped</a></li>
          </ul></dd>
<dt><a name="toDerivNumContextProc" href="#toDerivNumContextProc"><span>toDerivNumContextProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc toDerivNumContextProc[T](spline: InterpolatorType[T]): NumContextProc[T, float]" href="numericalnim/interpolate.html#toDerivNumContextProc%2CInterpolatorType%5BT%5D">interpolate: proc toDerivNumContextProc[T](spline: InterpolatorType[T]): NumContextProc[T, float]</a></li>
          </ul></dd>
<dt><a name="toDerivProc" href="#toDerivProc"><span>toDerivProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc toDerivProc[T](spline: InterpolatorType[T]): InterpolatorProc[T]" href="numericalnim/interpolate.html#toDerivProc%2CInterpolatorType%5BT%5D">interpolate: proc toDerivProc[T](spline: InterpolatorType[T]): InterpolatorProc[T]</a></li>
          </ul></dd>
<dt><a name="toNumContextProc" href="#toNumContextProc"><span>toNumContextProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: converter toNumContextProc[T](spline: InterpolatorType[T]): NumContextProc[T, float]" href="numericalnim/interpolate.html#toNumContextProc.c%2CInterpolatorType%5BT%5D">interpolate: converter toNumContextProc[T](spline: InterpolatorType[T]): NumContextProc[T, float]</a></li>
          </ul></dd>
<dt><a name="toProc" href="#toProc"><span>toProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="interpolate: proc toProc[T](spline: InterpolatorType[T]): InterpolatorProc[T]" href="numericalnim/interpolate.html#toProc%2CInterpolatorType%5BT%5D">interpolate: proc toProc[T](spline: InterpolatorType[T]): InterpolatorProc[T]</a></li>
          </ul></dd>
<dt><a name="toTensor" href="#toTensor"><span>toTensor:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc toTensor(v: Vector): Tensor[float]" href="numericalnim/utils.html#toTensor%2CVector">utils: proc toTensor(v: Vector): Tensor[float]</a></li>
          </ul></dd>
<dt><a name="trapz" href="#trapz"><span>trapz:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="integrate: proc trapz[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 500;
         ctx: NumContext[T, float] = nil): T" href="numericalnim/integrate.html#trapz%2CNumContextProc%5BT%2Cfloat%5D%2Cfloat%2Cfloat%2Cint%2CNumContext%5BT%2Cfloat%5D">integrate: proc trapz[T](f: NumContextProc[T, float]; xStart, xEnd: float; N = 500;
         ctx: NumContext[T, float] = nil): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="integrate: proc trapz[T](Y: openArray[T]; X: openArray[float]): T" href="numericalnim/integrate.html#trapz%2CopenArray%5BT%5D%2CopenArray%5Bfloat%5D">integrate: proc trapz[T](Y: openArray[T]; X: openArray[float]): T</a></li>
          </ul></dd>
<dt><a name="Vector" href="#Vector"><span>Vector:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: object Vector" href="numericalnim/utils.html#Vector">utils: object Vector</a></li>
          </ul></dd>
<dt><a name="vectorNorm" href="#vectorNorm"><span>vectorNorm:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: proc vectorNorm[T](v: Tensor[T]): T" href="numericalnim/optimize.html#vectorNorm%2CTensor%5BT%5D">optimize: proc vectorNorm[T](v: Tensor[T]): T</a></li>
          </ul></dd>
<dt><a name="Wolfe" href="#Wolfe"><span>Wolfe:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: LineSearchCriterion.Wolfe" href="numericalnim/optimize.html#Wolfe">optimize: LineSearchCriterion.Wolfe</a></li>
          </ul></dd>
<dt><a name="WolfeStrong" href="#WolfeStrong"><span>WolfeStrong:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="optimize: LineSearchCriterion.WolfeStrong" href="numericalnim/optimize.html#WolfeStrong">optimize: LineSearchCriterion.WolfeStrong</a></li>
          </ul></dd>
</dl>
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-03-29 09:01:58 UTC</small>
      </div>
    </div>
  </div>
  
  <!-- Google fonts -->
  <link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>
</body>
</html>
