nimTitle	differentiate	numericalnim/differentiate.html	module src/numericalnim/differentiate		0
nim	diff1dForward	numericalnim/differentiate.html#diff1dForward,proc(U),U,U	proc diff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		36
nim	diff1dBackward	numericalnim/differentiate.html#diff1dBackward,proc(U),U,U	proc diff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		41
nim	diff1dCentral	numericalnim/differentiate.html#diff1dCentral,proc(U),U,U	proc diff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		46
nim	secondDiff1dForward	numericalnim/differentiate.html#secondDiff1dForward,proc(U),U,U	proc secondDiff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		51
nim	secondDiff1dBackward	numericalnim/differentiate.html#secondDiff1dBackward,proc(U),U,U	proc secondDiff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		55
nim	secondDiff1dCentral	numericalnim/differentiate.html#secondDiff1dCentral,proc(U),U,U	proc secondDiff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T		59
nim	tensorGradient	numericalnim/differentiate.html#tensorGradient,proc(Tensor[U]),Tensor[U],U,bool	proc tensorGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];\n                                 h: U = U(0.000001); fastMode: bool = false): Tensor[\n    T]		64
nim	tensorGradient	numericalnim/differentiate.html#tensorGradient,proc(Tensor[U]),Tensor[U],U,bool_2	proc tensorGradient[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];\n                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]		93
nim	tensorJacobian	numericalnim/differentiate.html#tensorJacobian,proc(Tensor[U]),Tensor[U],U,bool	proc tensorJacobian[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];\n                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]		126
nim	mixedDerivative	numericalnim/differentiate.html#mixedDerivative,proc(Tensor[U]),Tensor[U],,U	proc mixedDerivative[U, T](f: proc (x: Tensor[U]): T; x0: var Tensor[U];\n                      indices: (int, int); h: U = U(0.000001)): T		141
nim	tensorHessian	numericalnim/differentiate.html#tensorHessian,proc(Tensor[U]),Tensor[U],U	proc tensorHessian[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];\n                                h: U = U(0.000001)): Tensor[T]		171
nim	checkGradient	numericalnim/differentiate.html#checkGradient,proc(Tensor[U]),proc(Tensor[U]),Tensor[U],T	proc checkGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T;\n                                fGrad: proc (x: Tensor[U]): Tensor[T];\n                                x0: Tensor[U]; tol: T): bool		192
nim	checkGradient	numericalnim/differentiate.html#checkGradient,proc(Tensor[U]),proc(Tensor[U]),Tensor[U],T_2	proc checkGradient[U; T](f: proc (x: Tensor[U]): Tensor[T];\n                    fGrad: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U]; tol: T): bool		202
nimgrp	checkgradient	numericalnim/differentiate.html#checkGradient-procs-all	proc		192
nimgrp	tensorgradient	numericalnim/differentiate.html#tensorGradient-procs-all	proc		64
heading	Differentiation	numericalnim/differentiate.html#differentiation	 Differentiation		0
