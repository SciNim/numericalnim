diff1dForward	numericalnim/differentiate.html#diff1dForward,proc(U),U,U	differentiate: diff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
diff1dBackward	numericalnim/differentiate.html#diff1dBackward,proc(U),U,U	differentiate: diff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
diff1dCentral	numericalnim/differentiate.html#diff1dCentral,proc(U),U,U	differentiate: diff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
secondDiff1dForward	numericalnim/differentiate.html#secondDiff1dForward,proc(U),U,U	differentiate: secondDiff1dForward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
secondDiff1dBackward	numericalnim/differentiate.html#secondDiff1dBackward,proc(U),U,U	differentiate: secondDiff1dBackward[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
secondDiff1dCentral	numericalnim/differentiate.html#secondDiff1dCentral,proc(U),U,U	differentiate: secondDiff1dCentral[U, T](f: proc (x: U): T; x0: U; h: U = U(0.000001)): T	
tensorGradient	numericalnim/differentiate.html#tensorGradient,proc(Tensor[U]),Tensor[U],U,bool	differentiate: tensorGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];\n                                 h: U = U(0.000001); fastMode: bool = false): Tensor[\n    T]	
tensorGradient	numericalnim/differentiate.html#tensorGradient,proc(Tensor[U]),Tensor[U],U,bool_2	differentiate: tensorGradient[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];\n                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]	
tensorJacobian	numericalnim/differentiate.html#tensorJacobian,proc(Tensor[U]),Tensor[U],U,bool	differentiate: tensorJacobian[U, T](f: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U];\n                     h: U = U(0.000001); fastMode: bool = false): Tensor[T]	
mixedDerivative	numericalnim/differentiate.html#mixedDerivative,proc(Tensor[U]),Tensor[U],,U	differentiate: mixedDerivative[U, T](f: proc (x: Tensor[U]): T; x0: var Tensor[U];\n                      indices: (int, int); h: U = U(0.000001)): T	
tensorHessian	numericalnim/differentiate.html#tensorHessian,proc(Tensor[U]),Tensor[U],U	differentiate: tensorHessian[U; T: not Tensor](f: proc (x: Tensor[U]): T; x0: Tensor[U];\n                                h: U = U(0.000001)): Tensor[T]	
checkGradient	numericalnim/differentiate.html#checkGradient,proc(Tensor[U]),proc(Tensor[U]),Tensor[U],T	differentiate: checkGradient[U; T: not Tensor](f: proc (x: Tensor[U]): T;\n                                fGrad: proc (x: Tensor[U]): Tensor[T];\n                                x0: Tensor[U]; tol: T): bool	
checkGradient	numericalnim/differentiate.html#checkGradient,proc(Tensor[U]),proc(Tensor[U]),Tensor[U],T_2	differentiate: checkGradient[U; T](f: proc (x: Tensor[U]): Tensor[T];\n                    fGrad: proc (x: Tensor[U]): Tensor[T]; x0: Tensor[U]; tol: T): bool	
Differentiation	numericalnim/differentiate.html#differentiation	 Differentiation	
